
# Event Loop

  자바 스크리트의 큰 특징 중 하나는 '단일 스레드' 기반의 언어라는 점이다. 스레드가 하나라는 말은 곹 동시에 하나의 작업 만을 처리할 수 있다는 말이다. 하지만 실제로 자바스크립트가 사용되는 환경을 생각해보면 많은 작업이 동시에 처리되고 있는 걸 볼 수 있다. 어떻게 스레드가 하나인데 이런 일이 가능할까? 질문을 바꿔보면 __'자바스크립트는 어떻게 동시성(Concurrency)'__ 을 지원 하는걸까 ?  
  
  이때 등장하는 개념이 바로 __'이벤트 루프'__ 이다. Node.js를 소개할때 __'이벤트 루프 기반의 비동기 방식으로 Non-Blocking IO를 지원'__ 과 같은 문구를 본 적이 있을것이다. 즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원한다. 
  
## ECMAScrit에는 이벤트 루프가 없다.
  
  웬만큼 두꺼운 자바스크립트 관련 서적을을 뒤져봐도 이벤트 루프에 대한 설명은 의외로 쉽게 찾아보기가 힘들다. 그 이유는 아마, 실제로 ECMAScript 스펙에 이벤트 루프에 대한 내용이 없기 때문일 것이다. 좀더 구체적으로 표현하면 'ECMAScript에는 동시성과 비동기와 관련된 언급이 없다' 라고 할수 있다. 실제로 V8과 같은 자바스크립트 엔진은 단일 호출 스택(Call Stack)을 사용하며, 요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리할 뿐이다. 그렇다면 비동기 요청은 어떻게 이루어지며, 동시성에 대한 처리는 누가 하는 걸까? 바로 이 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 Node.js가 담당한다.
  
![EventLoop](../image/eventloop.png)

  위 브라우저 환경을 담아낸 그림을 보면 우리가 비동기 호출을 위해 사용하는 setTimeout 이나 XMLHttpRequest 와 같은 함수들은 자바스크립트 엔진이 아닌 Wep API 영역에 따로 정의 되어져 있다. 또한 Event Loop와 Task Queue와 같은 장치도 자바스크립트 엔진 외부에 구현되어 있는 것을 볼수 있다.

![Node.js Systemn](../image/nodejssystem.jpg)
  
  위 node.js 의 환경을 그린 그림에서도 브라우저의 환경과 비슷한 구조를 볼 수 있다. 잘 알려진대로 Node.js는 비동기 IO를 지원하기위해 LIBUV 라이브러리를 사용하며, 이 LIBUV가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 LIBUV의 이벤트 루프를 통해 스케줄되고 실행된다.
  
  즉 자바스크립트가 '단일 스레드' 기반의 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이고, 실제 자바스크립트가 구동되는 환경(브라우저, Node.js 등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 '이벤트 루프'인 것이다.
  
## 단일 호출 스택과 Run-to-Completion

  자바스크립트의 함수가 실행되는 방식을 보통 "Run to Completion" 이라고 말한다. 이는 하나의 함수가 실행되면 이 함수의 실행이 끝날때 까지는 다른 어떤 작업도 끼어들지 못한다는 의미이다. 앞서 말했듯이 자바스클비트 엔진은 하나의 호출 스택을 사용하며, 현재 스택에 쌓여있는 모든 함수들이 실행을 마치고 스택에서 제거되기 전까지는 다른 어떠한 함수도 실행될 수 없다.
  
![task_event1](../image/task_event1.png)

#### 위의 예제를 실행하면 콘솔에는 'bar!' > 'foo!' > 'baz!' 의 순서로 찍히게 된다.
#### (위의 코드가 전역 환경에서 실행된다고 가정하고, 주석으로 각 호출 스택을 숫자로 적어 보았다.)


![task_event2](../image/task_event2.png)
  
## Task Queue 와 Event Loop

  
