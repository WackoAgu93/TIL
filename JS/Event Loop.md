
# Event Loop

  자바 스크리트의 큰 특징 중 하나는 '단일 스레드' 기반의 언어라는 점이다. 스레드가 하나라는 말은 곹 동시에 하나의 작업 만을 처리할 수 있다는 말이다. 하지만 실제로 자바스크립트가 사용되는 환경을 생각해보면 많은 작업이 동시에 처리되고 있는 걸 볼 수 있다. 어떻게 스레드가 하나인데 이런 일이 가능할까? 질문을 바꿔보면 __'자바스크립트는 어떻게 동시성(Concurrency)'__ 을 지원 하는걸까 ?  
  
  이때 등장하는 개념이 바로 __'이벤트 루프'__ 이다. Node.js를 소개할때 __'이벤트 루프 기반의 비동기 방식으로 Non-Blocking IO를 지원'__ 과 같은 문구를 본 적이 있을것이다. 즉, 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원한다. 
  
## ECMAScrit에는 이벤트 루프가 없다.
  
  웬만큼 두꺼운 자바스크립트 관련 서적을을 뒤져봐도 이벤트 루프에 대한 설명은 의외로 쉽게 찾아보기가 힘들다. 그 이유는 아마, 실제로 ECMAScript 스펙에 이벤트 루프에 대한 내용이 없기 때문일 것이다. 좀더 구체적으로 표현하면 'ECMAScript에는 동시성과 비동기와 관련된 언급이 없다' 라고 할수 있다. 실제로 V8과 같은 자바스크립트 엔진은 단일 호출 스택(Call Stack)을 사용하며, 요청이 들어올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리할 뿐이다. 그렇다면 비동기 요청은 어떻게 이루어지며, 동시성에 대한 처리는 누가 하는 걸까? 바로 이 자바스크립트 엔진을 구동하는 환경, 즉 브라우저나 Node.js가 담당한다.
  
![EventLoop](../image/eventloop.png)

  위 브라우저 환경을 담아낸 그림을 보면 우리가 비동기 호출을 위해 사용하는 setTimeout 이나 XMLHttpRequest 와 같은 함수들은 자바스크립트 엔진이 아닌 Wep API 영역에 따로 정의 되어져 있다. 또한 Event Loop와 Task Queue와 같은 장치도 자바스크립트 엔진 외부에 구현되어 있는 것을 볼수 있다.

![Node.js Systemn](../image/nodejssystem.jpg)
  
  위 node.js 의 환경을 그린 그림에서도 브라우저의 환경과 비슷한 구조를 볼 수 있다. 잘 알려진대로 Node.js는 비동기 IO를 지원하기위해 LIBUV 라이브러리를 사용하며, 이 LIBUV가 이벤트 루프를 제공한다. 자바스크립트 엔진은 비동기 작업을 위해 Node.js의 API를 호출하며, 이때 넘겨진 콜백은 LIBUV의 이벤트 루프를 통해 스케줄되고 실행된다.
  
  즉 자바스크립트가 '단일 스레드' 기반의 언어라는 말은 '자바스크립트 엔진이 단일 호출 스택을 사용한다'는 관점에서만 사실이고, 실제 자바스크립트가 구동되는 환경(브라우저, Node.js 등)에서는 주로 여러 개의 스레드가 사용되며, 이러한 구동 환경이 단일 호출 스택을 사용하는 자바 스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 '이벤트 루프'인 것이다.
  
## 단일 호출 스택과 Run-to-Completion

  자바스크립트의 함수가 실행되는 방식을 보통 "Run to Completion" 이라고 말한다. 이는 하나의 함수가 실행되면 이 함수의 실행이 끝날때 까지는 다른 어떤 작업도 끼어들지 못한다는 의미이다. 앞서 말했듯이 자바스클비트 엔진은 하나의 호출 스택을 사용하며, 현재 스택에 쌓여있는 모든 함수들이 실행을 마치고 스택에서 제거되기 전까지는 다른 어떠한 함수도 실행될 수 없다.
  
```javascript
  function delay(){
    for (var i = 0; i < 100000; i++);
  }
  function foo() {
    delay();
    bar();
    console.log('foo!'); // (3)
  }
  function bar() {
    delay();
    console.log('bar!'); // (2)
  }
  function baz() {
    console.log('baz!'); // (4)
  }
  
  setTimeout(baz, 10); // (1)
  foo();
```
   __위의 예제를 실행하면 콘솔에는 'bar!' > 'foo!' > 'baz!' 의 순서로 찍히게 된다.__  
   __(위의 코드가 전역 환경에서 실행된다고 가정하고, 주석으로 각 호출 스택을 숫자로 적어 보았다.)__


![task_event2](../image/task_event2.png)
  __(위 코드의 첫 줄이 실행될 때에 호출 스택의 맨 아래에 익명 함수가 하나 추가되며, 마지막 라인 까지 실행되고 나서야 스택에서 제거된다.)__
  
  __①__ `setTimeout` 함수는 브라우저에게 타이머 이벤트를 요청한 후에 바로 스택에서 제거 된다. __②~③__ 그 후에 `foo` 함수가 스택에 추가 되고, `foo` 함수가 내부적으로 실행하는 함수들이 차례로 스택에 추가 되었다가, 제거된다. 마지막으로 `foo` 함수가 실행을 마치면서 후출 스택이 비워지게 되고, __④__ 그 이후에 `baz` 함수가 스택에 추가되어 콘솔에 'baz!'가 직히게 된다.  
  (결과적으로 `baz` 는 10ms보다 더 늦게 실행되게 될 것이다. 즉, 자바스크립트의 타이머는 정확한 타이밍을 보장해 주지 않는다.)
  
## Task Queue 와 Event Loop

  `setTimeout` 함수를 통해 넘긴 `baz` 함수는 어떻게 `foo` 함수가 끝나자 마자 실행될수 있을까? 즉 어디서 대기하고 있다가 누구를 통해 실행되는가? 바로 이 역할을 하는 것이 __Task Queue__ 와 __Event Loop__ 이다. 태스크 큐는 말 그대로 콜백 함수들이 대기하는 큐(__FIFO__) 형태의 배열이라 할 수 있고, 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 해준다.
  
```javascript
  while(queue.waitForMessage()){
    queue.processNextMessage();
  }
```

  위 코드의 `waitForMessage()` 메소드는 현재 실행중인 태스크가 없을 때 다음 태스크가 큐에 추가도리 때까지 대기하는 역할을 한다. 이런 식으로 이벤트 루프는 __현재 실행중인 태스크가 없는지__ 와 __태스크 큐에 태스크가 있는지__ 를 반복적으로 확인하는 것이다.  
  
  - 모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.
  - 이벤트 루프는 '현재 실행중인 태스크가 없을때'(주로 호출 스택이 비워졌을 때), 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다.
  
```javascript
  function delay(){
    for (var i = 0; i < 100000; i++);
  }
  function foo() {
    delay();
    console.log('foo!');
  }
  function bar() {
    delay();
    console.log('bar!');
  }
  function baz() {
    delay();
    console.log('baz!');
  }
  
  setTimeout(foo, 10);
  setTimeout(bar, 10);
  setTimeout(baz, 10);
```
  
  이 코드를 실행하면 아무런 지연 없이 `setTimeout` 함수가 세 번 호출된 이후에 실행을 마치고 호출 스택이 비워질 것이다. 그리고 10ms가 지나는 순간 `foo`,`bar`,`baz` 함수가 순차적으로 태스크 큐에 추가된다. 이벤트 루프는 `foo`함수가 태스크 큐에 들어오자 마자, 호출 스택이 비어있으므로 바로 `foo`를 실행해서 호출 스택에 추가한다. `foo`함수의 실행이 끝나고 호출 스택이 비워지면 이벤트 루프가 다시 큐에서 다음 콜백인 `bar`를 가져와 실행한다. `bar`의 실행이 긑나면 마찬가지로 큐에 남아있는 `bar`를 큐에서 가져와 실행한다. 그리고 `baz`까지 실행이 모두 완료되면 현재 진행중인 태스크도 없고 태스크 큐도 비어잇기 때문에, 이벤트 루프는 새로운 태스크가 태스크 큐에 추가될 때까지 대기한다.
  
  
